---
title: "FASTA Metrics Report"
format:
  html:
    output-file: report.html
    theme: cosmo
    toc: true
    toc-depth: 3
    code-folding: show
    smooth-scroll: true
    css: style.css
execute:
  echo: false
editor: visual
---

# Resumen

Esta seccion del informe resume las métricas de longitud y porcentaje de recolección de residuos (GC%) de todos los archivos FASTA procesados.
Todos los gráficos y resúmenes se adaptan automáticamente al número de archivos presentes en data.
---

## Gráficos de longitud y GC%

Primero se cargan las tablas combinadas y a partir de ello se generan:
Violines plots, boxplots, densidad plot, que muestran la variabilidad del contenido GC por archivo, junto con el número total de secuencias representadas.

Distribuciones de longitud, mediante violines con puntos individuales (quasirandom) y una versión alternativa basada en histogramas superpuestos para comparar patrones globales entre genomas.

Densidades de GC%, útiles para observar diferencias en la forma de la distribución entre archivos multifasta.

En conjunto, estos gráficos permiten evaluar rápidamente si los fastas difieren en tamaño, homogeneidad y composición nucleotídica.

```{r}
suppressPackageStartupMessages({
library(tidyverse)
library(pheatmap)
library(ggplot2)
library(ggridges)
library(ggbeeswarm)
library(cowplot)
library(dplyr)
library(seqinr)
})



combined <- read_tsv("results/tables/combined_table.tsv") %>%
  rename(
    gc_percent = gc,
    length = length
  )

combined$file <- factor(combined$file)

combined$file <- sapply(combined$file, function(x) {
    x <- sub(".*Tcruzi", "", x)      # quita prefijo
    x <- sub("2018$", "", x)         # si termina en 2018, lo borra
    x <- sub("\\.fasta.*$", "", x)   # quita extensión
    return(x)
})

summary_tbl <- combined %>%
  group_by(file) %>%
  summarise(
    n_sequences = n(),
    mean_length = mean(length),
    median_length = median(length),
    sd_length = sd(length),
    p25_length = quantile(length, 0.25),
    p75_length = quantile(length, 0.75),
    mean_gc = mean(gc_percent),
    median_gc = median(gc_percent),
    sd_gc = sd(gc_percent),
    p25_gc = quantile(gc_percent, 0.25),
    p75_gc = quantile(gc_percent, 0.75)
  )

##

### Plot function for GC violin ###
plot_violin_gc <- function(data, plot_title, y_label) {
  data$file <- factor(data$file, levels = sort(unique(data$file)))

  count_data <- data %>%
    group_by(file) %>%
    summarise(count = n(), .groups = "drop")

  ggplot(data, aes(x = file, y = gc_percent, fill = file)) +
    geom_violin(alpha = 0.7, width = 0.5, show.legend = FALSE) +
    geom_boxplot(width = 0.1, fill = "white", alpha = 0.3, show.legend = FALSE) +
    scale_fill_brewer(palette = "Dark2") +
    geom_text(data = count_data,
              aes(x = file, y = max(data$gc_percent, na.rm = TRUE) * 1.05,
                  label = count),
              vjust = 0, color = "black", size = 3.5) +
    labs(title = plot_title, y = y_label) +
    theme_minimal() +
    scale_y_continuous(expand = expansion(mult = c(0.05, 0.15)))
}

### Plot function for length ###
plot_violin_length <- function(data, type, plot_title, x_label) {
  data$file <- factor(data$file, levels = sort(unique(data$file)))

  plot_data <- data %>%
    group_by(file) %>%
    mutate(count = n(),
           median_length = median(length)) %>%
    ungroup()

  label_data <- plot_data %>%
    distinct(file, .keep_all = TRUE)

  p <- ggplot(plot_data, aes(length, file, color = file)) +
    geom_quasirandom(groupOnX = FALSE, show.legend = FALSE,
                     size = 1, dodge.width = 0.9, alpha = 0.4) +
    labs(title = plot_title, x = x_label) +
    theme_minimal() +
    scale_color_brewer(palette = "Dark2") +
    geom_text(data = label_data,
              aes(x = Inf, y = file, label = count),
              hjust = -0.2, color = "black", size = 3.5) +
    coord_cartesian(clip = "off")

  if (type == "genome") {
    p <- p + scale_x_log10()
  } else {
    p <- p + scale_x_continuous(expand = expansion(mult = c(0.05, 0.2)))
  }

  return(p)
}

p_gc <- plot_violin_gc(combined, "Genome GC%", "gc_percent")
p_len <- plot_violin_length(combined, "genome", "Genome size", "length")

p_gc

p_len
```

Otra forma de visualizar %GC y longitud de secuencias.

```{r}

# Length distribution (overlapped)

ggplot(combined, aes(length, fill = file)) +
geom_histogram(alpha = 0.5, bins = 40, position = "identity") +
labs(
title = "Length distribution per FASTA",
x = "Sequence length (bp)",
y = "Count"
) +
theme_minimal()

# GC% distribution density plot

ggplot(combined, aes(gc_percent, fill = file)) +
geom_density(alpha = 0.6) +
labs(
title = "GC% distribution per FASTA",
x = "GC Percentage",
y = "Density"
) +
theme_minimal()

```

---

## Análisis de frecuencias nucleotídicas y PCA

Finalmente, se resumen las frecuencias dinucleotídicas y trinucleotídicas de cada secuencia y se utiliza un Análisis de Componentes Principales (PCA) 
para visualizar similitudes y diferencias en composición entre multifastas. El PCA permite proyectar cada secuencia en un espacio reducido, 
agrupando aquellas con perfiles de frecuencia similares y destacando posibles patrones taxonómicos, estructurales o técnicos en los multifastas.

---

```{r}
suppressPackageStartupMessages({
library(seqinr)
library(ggplot2)
library(ggfortify)
library(tidyverse)
})

df_di <- read_tsv("results/frequency/dinucleotide_combined.tsv")
df_tri <- read_tsv("results/frequency/trinucleotide_combined.tsv")

df_di$File <- sapply(df_di$File, function(x) {
    x <- sub(".*Tcruzi", "", x)      # quita prefijo
    x <- sub("2018$", "", x)         # si termina en 2018, lo borra
    x <- sub("\\.fasta.*$", "", x)   # quita extensión
    return(x)
})

df_tri$File <- sapply(df_tri$File, function(x) {
    x <- sub(".*Tcruzi", "", x)      # quita prefijo
    x <- sub("2018$", "", x)         # si termina en 2018, lo borra
    x <- sub("\\.fasta.*$", "", x)   # quita extensión
    return(x)
})

# function to string manipulation on sequence ID
transform_columns <- function(df, cols) {
  # Iterate over the specified columns
  for (col in cols) {
    # Replace '=' with '_'
    df[[col]] <- gsub("=", "_", df[[col]])              
    # Remove everything after ':' or ';'
    df[[col]] <- gsub("[:;].*", "", df[[col]])          
  }
  return(df)  # Return the modified data frame
}

df_tran_di <- transform_columns(df_di, "ID")
df_tran_tri <- transform_columns(df_tri, "ID")


# Convert dinucleotide columns to numeric
cols_to_convert_di <- c("aa", "tt", "ac", "gt", "ag", "ct", "ca", "tg", "cc", "gg", "ga", "tc", "at", "cg", "gc", "ta")
df_di[cols_to_convert_di] <- lapply(df_di[cols_to_convert_di], as.numeric)

# Convert trinucleotide columns to numeric
cols_to_convert_tri <- c("aaa", "aag", "aat", "aca", "acc", "act", "aga", "agg", "agt", "ata", "atc", "att", "caa", "cag", "cat", "cca", "ccc", "cct", "cga", "cgg", "cgt", "cta", "ctc", "ctt", "gaa", "gag", "gat", "gca", "gcc", "gct", "gga", "ggc", "ggt", "gta", "gtc", "gtt", "taa", "tag", "tat", "tca", "tcc", "tct", "tga", "tgg", "tgt", "tta", "ttc", "ttt")
df_tri[cols_to_convert_tri] <- lapply(df_tri[cols_to_convert_tri], as.numeric)


combine_data_frequencies <- function(data, genome_col = "File", id_col = "ID", tag) {
  if (tag == "din") {
    result_combained_data <- data.frame(
      "Genome" = data[, genome_col],
      "ID" = data[, id_col],
      "aa.tt" = data[,"aa"] + data[,"tt"],
      "ac.gt" = data[,"ac"] + data[,"gt"],
      "ag.ct" = data[,"ag"] + data[,"ct"],
      "ca.tg" = data[,"ca"] + data[,"tg"],
      "cc.gg" = data[,"cc"] + data[,"gg"],
      "ga.tc" = data[,"ga"] + data[,"tc"],
      "at" = data[,"at"],
      "cg" = data[,"cg"],
      "gc" = data[,"gc"],
      "ta" = data[,"ta"]
    )
  } else if (tag == "tri") {
result_combained_data <- data.frame(
  Genome = data[, genome_col],
  ID     = data[, id_col],

  aaa.ttt = data[,"aaa"] + data[,"ttt"],
  aag.ctt = data[,"aag"] + data[,"ctt"],
  aac.gtt = data[,"aac"] + data[,"gtt"],
  aat.att = data[,"aat"] + data[,"att"],

  acc.ggt = data[,"acc"] + data[,"ggt"],
  act.agt = data[,"act"] + data[,"agt"],
  aga.tct = data[,"aga"] + data[,"tct"],
  agg.cct = data[,"agg"] + data[,"cct"],

  ata.tat = data[,"ata"] + data[,"tat"],
  atc.gat = data[,"atc"] + data[,"gat"],

  caa.ttg = data[,"caa"] + data[,"ttg"],
  cag.ctg = data[,"cag"] + data[,"ctg"],
  cat.atg = data[,"cat"] + data[,"atg"],
  cac.gtg = data[,"cac"] + data[,"gtg"],

  cca.tgg = data[,"cca"] + data[,"tgg"],
  ccc.ggg = data[,"ccc"] + data[,"ggg"],
  cga.tcg = data[,"cga"] + data[,"tcg"],
  cta.tag = data[,"cta"] + data[,"tag"],

  gaa.ttc = data[,"gaa"] + data[,"ttc"],
  gag.ctc = data[,"gag"] + data[,"ctc"],
  gca.tgc = data[,"gca"] + data[,"tgc"],
  gta.tac = data[,"gta"] + data[,"tac"],
  gtc.gac = data[,"gtc"] + data[,"gac"],

  tca.tga = data[,"tca"] + data[,"tga"]
)
  } else {
    stop("Invalid tag specified. Use 'di' for dinucleotides or 'tri' for trinucleotides.")
  }

  return(result_combained_data)
}

combained_di <- combine_data_frequencies(df_di, tag="din")
combained_tri <- combine_data_frequencies(df_tri, tag="tri")

id_vector_di <- combained_di$ID
id_vector_tri <- combained_tri$ID

# Transform the ID: remove everything after ";" and replace "=" with "_"
id_vector_cleaned_di <- gsub(";.*", "", gsub("=", "_", id_vector_di))
id_vector_cleaned_di <- gsub("[:;].*", "", id_vector_cleaned_di) 

id_vector_cleaned_tri <- gsub(";.*", "", gsub("=", "_", id_vector_tri))
id_vector_cleaned_tri <- gsub("[:;].*", "", id_vector_cleaned_tri) 

# Asignar el vector limpio de vuelta al dataframe
combained_clean_di <- combained_di
combained_clean_di$ID <- id_vector_cleaned_di

combained_clean_tri <- combained_tri
combained_clean_tri$ID <- id_vector_cleaned_tri

perform_pca <- function(data, file_col = "File", id_col = "ID") {
  # Validate input data
  if (!file_col %in% names(data)) {
    stop(paste("Column", file_col, "not found in data"))
  }
  if (!id_col %in% names(data)) {
    stop(paste("Column", id_col, "not found in data"))
  }
  
  # Exclude 'file_col' and 'id_col' columns from numerical analysis
  pca_data <- data[, !(names(data) %in% c(file_col, id_col))]
  
  # Convert all columns to numeric, handling non-numeric values and NAs
  pca_data <- as.data.frame(lapply(pca_data, function(x) {
    x <- as.numeric(as.character(x))
    ifelse(is.na(x), 0, x)  # Replace NA with 0 (or adjust based on your preference)
  }))
  
  # Ensure no rows were dropped due to conversion issues
  if (nrow(pca_data) != nrow(data)) {
    stop("Mismatch between input data rows and processed PCA data rows")
  }
  
  # Perform the PCA
  pca_result <- prcomp(pca_data, scale. = TRUE)
  
  # Get PCA scores
  pca_scores <- as.data.frame(pca_result$x)
  
  # Add 'file_col' and 'id_col' columns to PCA results
  pca_scores <- cbind(data[, c(file_col, id_col)], pca_scores)
  
  # Plot the PCA using autoplot
  pca_plot <- autoplot(
    pca_result, 
    data = data, 
    colour = file_col, 
    loadings = TRUE, 
    loadings.label = TRUE, 
    loadings.colour = 'grey64', 
    alpha = 0.2, 
    size = 1
  ) +
    theme_minimal()
  
  # Return the results of the PCA and the graph
  return(list(pca_result = pca_result, pca_scores = pca_scores, pca_plot = pca_plot))
}

# Call the updated perform_pca function
perform_result_pca_di <- perform_pca(
  data = combained_clean_di, 
  file_col = "File", 
  id_col = "ID"
)

perform_result_pca_tri <- perform_pca(
  data = combained_clean_tri, 
  file_col = "File", 
  id_col = "ID"
)

print("plot dinucleotide")
perform_result_pca_di$pca_plot

print("plot trinucleotide")
perform_result_pca_di$pca_plot

```